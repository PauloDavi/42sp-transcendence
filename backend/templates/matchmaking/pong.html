{% extends 'shared/base.html' %}
{% load static %}
{% load i18n %}
{% block content %}
<div class="mb-3 mx-auto p-0">
  <canvas class="canvas-size" id="game"></canvas>
</div>
{% endblock %}

{% block scripts %}
<script>
document.addEventListener("DOMContentLoaded", () => {
  const wsScheme = window.location.protocol === "https:" ? "wss" : "ws";
  const socket = new WebSocket(`${wsScheme}://${window.location.host}/ws/game/{{ match.id }}/`);

  socket.onopen = function () {
    console.log("WebSocket do game conectado!");
  };

  socket.onerror = function (error) {
    console.error("Erro no WebSocket do game:", error);
  };

  socket.onclose = function () {
    console.log("WebSocket do game desconectado!");
  };

  const canvas = document.getElementById("game");
  const context = canvas.getContext("2d");
  const paddleHitSound = new Audio("{% static '/sound/paddleHit.mp3' %}");
  const wallHitSound = new Audio("{% static '/sound/wallHit.mp3' %}");

  const backgroundCanvas = document.createElement("canvas");
  const scoreboardCanvas = document.createElement("canvas");
  const scoreboardContext = scoreboardCanvas.getContext("2d");

  const keys = {};
  let leftScore, rightScore;
  let grid, paddleHeight, ballSize, paddleSpeed, maxPaddleY;
  let leftPaddle, rightPaddle, ball, lastTime, gameOver, winner, startGame = false;

  function initializeGame() {
    grid = canvas.width * 0.02;
    paddleHeight = grid * 5;
    ballSize = grid;
    paddleSpeed = canvas.height * 0.6;
    maxPaddleY = canvas.height - grid - paddleHeight;

    lastTime = 0;
    gameOver = false;
    winner = "";

    leftScore = 0;
    rightScore = 0;

    leftPaddle = createPaddle(grid * 2, canvas.height / 2 - paddleHeight / 2);
    rightPaddle = createPaddle(
      canvas.width - grid * 3,
      canvas.height / 2 - paddleHeight / 2
    );
    ball = createBall(canvas.width / 2, canvas.height / 2);

    paddleHitSound.load();
    wallHitSound.load();
  }

  function createPaddle(x, y) {
    return { x: x, y: y, width: grid, height: paddleHeight, dy: 0 };
  }

  function createBall(x, y) {
    return { x: x, y: y, width: ballSize, height: ballSize, dx: canvas.width * 0.4, dy: -canvas.width * 0.4, resetting: false };
  }

  function drawWidthHeight() {
    let y = 0;
    let x = 0;

    context.font = "10px Arial";
    context.textAlign = "center";
    
    for (let i = 0; i < 50; i++) {
      context.fillStyle = `hsl(${Math.random() * 360}, 100%, 50%)`;
      context.fillRect(x, y, grid, grid);
      context.fillRect(x, canvas.height - grid, grid, grid);
      context.fillStyle = "white";
      context.fillText(i, x + grid / 2, y + grid * 0.75);
      context.fillText(i, x + grid / 2, canvas.height - grid + y + grid * 0.75);
      x += grid;
    }

    y = grid;
    x = grid;

    context.font = "10px Arial";
    context.textAlign = "center";
    
    for (let i = 0; i < 23; i++) {
      context.fillStyle = `hsl(${Math.random() * 360}, 100%, 50%)`;
      context.fillRect(x, y, grid, grid);
      context.fillStyle = "white";
      context.fillText(i, x + grid / 2, y + grid * 0.75);
      y += grid;
    }
  }

  function loop(timestamp) {
    if (startGame) {
      if (gameOver) return drawEndGameScreen();
      
      const deltaTime = (timestamp - lastTime) / 1000;
      lastTime = timestamp;
      
      update(deltaTime);
      draw();
    }
    requestAnimationFrame(loop);
  }

  function update(deltaTime) {
    paddlesMovement(deltaTime);
    
    {% if is_player1 %}
    ballMovement(deltaTime);
    if (collides(ball, leftPaddle)) updateBallWhenColideWithPaddle(leftPaddle, leftPaddle.x + leftPaddle.width);
    else if (collides(ball, rightPaddle)) updateBallWhenColideWithPaddle(rightPaddle, rightPaddle.x - ball.width);
    updateBall(ball.x, ball.y);
    {% endif %}
  }

  function updateBallWhenColideWithPaddle(paddle, newBallX) {
    let impactPoint = ball.y + ball.height / 2 - (paddle.y + paddle.height / 2);
    let normalizedImpact = impactPoint / (paddle.height / 2);
    ball.dx *= -1.05;
    ball.dy = normalizedImpact * canvas.height * 0.3;
    ball.x = newBallX;
    paddleHitSound.play();
    playSound("paddle_hit");
  }

  function paddlesMovement(deltaTime) {
    {% if is_player1 %}rightPaddle{% else %}leftPaddle{% endif %}.dy = (keys["KeyW"] ? -paddleSpeed : 0) + (keys["KeyS"] ? paddleSpeed : 0);
    {% if is_player1 %}rightPaddle{% else %}leftPaddle{% endif %}.y += {% if is_player1 %}rightPaddle{% else %}leftPaddle{% endif %}.dy * deltaTime;

    constrainPaddle({% if is_player1 %}rightPaddle{% else %}leftPaddle{% endif %});
    if (keys["KeyW"] || keys["KeyS"]) {
      movePaddle({% if is_player1 %}rightPaddle{% else %}leftPaddle{% endif %}.y);
    }
  }

  function constrainPaddle(paddle) {
    if (paddle.y < grid) {
      paddle.y = grid;
    } else if (paddle.y > maxPaddleY) {
      paddle.y = maxPaddleY;
    }
  }

  function ballMovement(deltaTime) {
    ball.x += ball.dx * deltaTime;
    ball.y += ball.dy * deltaTime;

    if (ball.y < grid) {
      ball.y = grid;
      ball.dy *= -1;
      if (!ball.resetting) {
        wallHitSound.play();
        playSound("wall_hit");
      }
    } else if (ball.y + grid > canvas.height - grid) {
      ball.y = canvas.height - grid * 2;
      ball.dy *= -1;
      if (!ball.resetting) {
        wallHitSound.play();
        playSound("wall_hit");
      }
    }

    if ((ball.x < 0 || (ball.x + ballSize) > canvas.width) && !ball.resetting) {
      ball.resetting = true;
      updateScore();
      resetBall();
    }
  }

  function updateScore() {
    if (ball.x < 0) {
      rightScore++;
      updateScoreEvent();
    } else if ((ball.x + ballSize) > canvas.width) {
      leftScore++;
      updateScoreEvent();
    }
    drawScoreboard();
    {% comment %} if (leftScore >= 3) {
      endGame("Você ganhou", "{{ user.id }}", scoreUser1, scoreUser2);
    } else if (rightScore >= 3) {
      endGame("Você perdeu", {% if is_player1 %} "{{ match.user2.id }}" {% else %} "{{ match.user1.id }}" {% endif %}, scoreUser1, scoreUser2);
    } {% endcomment %}
  }

  function resetBall() {
    setTimeout(() => {
      ball.resetting = false;
      ball.x = canvas.width / 2;
      ball.y = canvas.height / 2;
      ball.dx = (Math.random() > 0.5 ? 1 : -1) * canvas.width * 0.4;
      ball.dy = (Math.random() > 0.5 ? 1 : -1) * canvas.width * 0.4;
    }, 1000 + Math.random() * 500);
  }

  function draw() {
    context.clearRect(0, 0, canvas.width, canvas.height);

    context.fillStyle = "white";
    context.fillRect(leftPaddle.x, leftPaddle.y, leftPaddle.width, leftPaddle.height);
    context.fillRect(rightPaddle.x, rightPaddle.y, rightPaddle.width, rightPaddle.height);
    context.fillRect(ball.x, ball.y, ball.width, ball.height);

    context.drawImage(scoreboardCanvas, 0, 0);
    context.drawImage(backgroundCanvas, 0, 0);
  }

  function createBackground() {
    const backgroundContext = backgroundCanvas.getContext("2d");

    backgroundCanvas.width = canvas.width;
    backgroundCanvas.height = canvas.height;

    backgroundContext.fillStyle = "lightgrey";
    backgroundContext.fillRect(0, 0, backgroundCanvas.width, grid);
    backgroundContext.fillRect(0, backgroundCanvas.height - grid, backgroundCanvas.width, backgroundCanvas.height);

    for (let i = grid; i < backgroundCanvas.height - grid; i += grid * 2) {
      backgroundContext.fillRect(backgroundCanvas.width / 2 - grid / 2, i, grid, grid);
    }
  }

  function drawScoreboard() {
    scoreboardCanvas.width = canvas.width;
    scoreboardCanvas.height = canvas.height;

    scoreboardContext.clearRect(0, 0, scoreboardCanvas.width, scoreboardCanvas.height);
    scoreboardContext.fillStyle = "white";

    scoreboardContext.font = canvas.height * 0.05 + "px Arial";
    scoreboardContext.textAlign = "center";
    scoreboardContext.fillText(leftScore, scoreboardCanvas.width * 0.25, scoreboardCanvas.height * 0.1);
    scoreboardContext.fillText(rightScore, scoreboardCanvas.width * 0.75, scoreboardCanvas.height * 0.1);
  }

  function adjustCanvasResolution() {
    const dpr = window.devicePixelRatio || 1;
    const width = canvas.clientWidth * dpr;
    const height = canvas.clientHeight * dpr;

    canvas.width = width;
    canvas.height = height;
    canvas.style.width = `${canvas.clientWidth}px`;
    canvas.style.height = `${canvas.clientHeight}px`;

    initializeGame();
    createBackground();
    drawScoreboard();
    draw();
    drawWidthHeight();
  }

  function collides(obj1, obj2) {
    return (
      obj1.x < obj2.x + obj2.width &&
      obj1.x + obj1.width > obj2.x &&
      obj1.y < obj2.y + obj2.height &&
      obj1.y + obj1.height > obj2.y
    );
  }

  function drawEndGameScreen() {
    context.fillStyle = "rgba(0, 0, 0, 0.7)";
    context.fillRect(0, 0, canvas.width, canvas.height);

    context.fillStyle = "white";
    context.font = canvas.height * 0.06 + "px Arial";
    context.textAlign = "center";
    context.fillText(winner, canvas.width / 2, canvas.height / 2);
  }

  function adjustCanvasSize() {
    const header = document.querySelector("header");
    const container = canvas.parentElement;

    let availableHeight = window.innerHeight - header.offsetHeight - 32;
    let width = availableHeight * 2;
    if (width > window.innerWidth) {
      width = window.innerWidth;
      availableHeight = width / 2;
    }

    container.style.width = `${width}px`;
    container.style.height = `${availableHeight}px`;
    canvas.width = width;
    canvas.height = availableHeight;
  }

  socket.onmessage = (event) => {
    const data = JSON.parse(event.data);
    if (data.type === "update_paddle") {
      if (data.user_id !== "{{ user.id }}") {
        {% if is_player1 %}leftPaddle{% else %}rightPaddle{% endif %}.y = data.position * canvas.height;
      }
    } else if (data.type === "start_game") {
      startGame = true;
    }
    {% if not is_player1 %}
    else if (data.type === "update_ball") {
      ball.x = data.ball_x * canvas.width;
      ball.y = data.ball_y * canvas.height;
    } else if (data.type === "update_score") {
      leftScore = data.left_score;
      rightScore = data.right_score;
      drawScoreboard();
    } else if (data.type === "sound_play") {
      if (data.sound === "paddle_hit") {
        paddleHitSound.play();
      } else if (data.sound === "wall_hit") {
        wallHitSound.play();
      }
    }
    {% endif %}
  };

  function playSound(sound) {
    if (socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({
        event: "play_sound",
        sound: sound
      }));
    }
  }

  function movePaddle(y) {
    if (socket.readyState === WebSocket.OPEN) {
      let normalizedY = y / canvas.height;
      socket.send(JSON.stringify({
        event: "update_paddle",
        user_id: "{{ user.id }}",
        position: normalizedY
      }));
    }
  }

  function updateBall(x, y) {
    if (socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({
        event: "update_ball",
        ball_x: x / canvas.width,
        ball_y: y / canvas.height
      }));
    }
  }

  function updateScoreEvent() {
    if (socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({
        event: "update_score",
        right_score: rightScore,
        left_score: leftScore
      }));
    }
  }

  function endGame(winningPlayer, winnerId, scoreUser1, scoreUser2) {
    gameOver = true;
    winner = winningPlayer;
    setTimeout(drawEndGameScreen, 500);

    if (socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({
        event: "game_over",
        winner_id: winnerId,
        score_user1: scoreUser1,
        score_user2: scoreUser2
      }));
    }
  }

  document.addEventListener("keydown", (e) => {
    if (["KeyW", "KeyS"].includes(e.code)) {
      e.preventDefault();
      keys[e.code] = true;
    }
  });

  document.addEventListener("keyup", (e) => {
    if (["KeyW", "KeyS"].includes(e.code)) {
      e.preventDefault();
      keys[e.code] = false;
    }
  });

  adjustCanvasSize();
  adjustCanvasResolution();
  requestAnimationFrame(loop);
});
</script>
{% endblock %}
